---
title: '[가상메모리] 운영체제가 메모리 관리를 하는 방법'
date: '2025-06-18 18:26'
description: '개발자로서 프로그램을 만들다 보면 이 프로그램에 대한 메모리는 얼마나 사용하는지 궁금할 때가 있다. 다른 프로그램과 동시에 실행이 되어도 충돌 나지 않고 잘 실행되는 이유가 뭘까? 바로 운영체제가 메모리를 잘 관리하고 있기 때문이다.'
section: 'Computer Science'
category: '운영체제'
slug: 'virtual-memory'
tags: ['MMU', '가상메모리', '메모리관리', '운영체제', '주소바인딩']
image: '/images/posts/post8/image.png'
---

## 시작하기

개발자로서 프로그램을 만들다 보면 이 프로그램에 대한 메모리는 얼마나 사용하는지 궁금할 때가 있다.  
다른 프로그램과 동시에 실행이 되어도 충돌 나지 않고 잘 실행되는 이유가 뭘까?  
바로 **운영체제가 메모리를 잘 관리**하고 있기 때문이다.

운영체제의 메모리 관리 방식과 **가상 메모리**라는 개념이 숨어있다.  
가상 메모리가 생겨나게 된 배경부터 **주소 바인딩, MMU, 메모리를 효율적으로 관리하는 기술** 등에 대해 알아보자.

## 가상 메모리란?

<img src="/images/posts/post8/1.png" />

**가상 메모리(Virtual Memory)** 는 말 그대로 '가상의' 메모리인데,  
**실제 메모리(RAM)보다 더 큰 메모리를 쓰는 것처럼 보이게 만든 운영체제가 사용하는 기술**이다.

실제로는 하나의 물리적인 메모리 위에서 여러 프로그램이 올라가는데,  
운영체제는 각 프로그램에게 **마치 자기만의 독립적인 메모리를 가진 것처럼 착각**하게 만든다.

### 🤔 그러면 왜 가상 메모리가 필요한 것일까?

- 가상메모리가 없다면 남은 프로그램 공간이 여러 **작은 조각으로 쪼개져 있는 경우**,  
  **충분한 메모리 공간이 있더라도** 연속적인 공간이 없기 때문에 새로운 프로그램을 로드하지 못함
- 프로그램은 **물리적인 메모리보다 더 많은 메모리**를 할당받을 수 없기 때문에 실행이 안 됨
- **프로세스 간 메모리 충돌**도 발생할 수 있음

이런 문제를 해결하기 위해 가상 메모리가 생겼다.

> 가상 메모리는 실제 메모리 구조를 프로세스로부터 숨기고  
> **마치 무한히 메모리를 사용하는 것처럼 추상화시켜서 프로그램의 유연성과 안정성을 높인다**

## 주소 바인딩과 MMU

### 논리적 주소 VS 물리적 주소

| 구분                                               | 설명                                                                                                                           |
| -------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **논리적 주소 (Logical Address, Virtual Address)** | 프로세스마다 독립적으로 가지는 주소 공간<br>각 프로세스마다 0번지부터 시작<br>CPU나 프로세스가 보는 주소<br>개발자가 보는 주소 |
| **물리적 주소 (Physical Address)**                 | 메모리(RAM)에 실제로 올라가는 위치                                                                                             |

운영체제는 이 둘을 연결시켜 주는 역할을 한다.  
프로그램은 **논리 주소만 사용**하고, **물리 주소로의 매핑은 운영체제가 처리**해준다.

### 주소 바인딩 (Address Binding)

**논리주소를 물리주소로 바꾸는 과정**을 주소 바인딩이라고 한다.  
이 주소를 언제 바꾸느냐에 따라 다음 3가지로 나뉜다.

1. **Compile time binding (컴파일 시간 바인딩)**
   - 컴파일 시 이미 주소가 결정됨 (주소 고정)
   - 메모리 위치를 바꾸려면 다시 컴파일해야 함
   - 컴파일러는 **절대코드(Absolute code)** 를 생성함

2. **Load time binding (로딩 시간 바인딩)**
   - 프로그램이 메모리에 **로드되는 순간** 주소가 결정됨
   - **재배치 가능 코드(Relocatable code)** 를 생성함

3. **Execution time binding (실행 시간 바인딩)** ✨
   - 실행 중에도 물리 주소가 바뀔 수 있음 → **가상 메모리 구현의 핵심**
   - **MMU 하드웨어 지원** 필요
   - 대부분의 시스템에서 사용되는 방식

## MMU (Memory Management Unit)

<img src="/images/posts/post8/2.png" />

**논리 주소를 물리 주소로 변환**해주는 **하드웨어 장치**

- CPU는 항상 **논리 주소**를 생성
- MMU는 이 논리 주소에 **기준(base) 주소값**을 더해서 물리 주소로 변환
- 기준 주소는 **운영체제가 프로세스마다 설정**함

> 사용자 프로그램은 오직 **논리 주소만 사용**하며,  
> 실제 물리 주소는 **MMU와 운영체제**가 알아서 처리한다.

## 메모리를 더 효율적으로 쓰기 위한 방법들

### 1. 다이나믹 로딩 (Dynamic Loading)

- 프로그램 전체를 메모리에 **미리 다 올리지 않고**,  
  **필요할 때마다 동적으로 올리는** 방식
- 메모리 절약, 실행 속도 향상
- 가끔씩 사용되는 많은 양의 코드(예: 오류 처리 등)에 유용
- **운영체제 없이도** 개발자가 직접 구현 가능

### 2. 다이나믹 링킹 (Dynamic Linking)

- 여러 컴파일 파일을 **하나의 실행 파일로 묶는 과정**이 Linking
- 프로그램이 **같은 라이브러리를 공유**함으로써 **메모리 낭비 방지**

| 방식                            | 설명                                            |
| ------------------------------- | ----------------------------------------------- |
| **정적 링킹 (Static Linking)**  | 모든 라이브러리 코드가 실행 파일에 포함됨       |
| **동적 링킹 (Dynamic Linking)** | 라이브러리를 실행 중에 메모리에 로드해서 연결함 |

### 3. 스와핑 (Swapping)

- 프로세스를 **디스크로 내보내거나 다시 메모리로 불러오는** 기술
- 메모리가 부족하면 **우선순위가 낮은 프로세스는 내보내고**, **우선순위가 높은 프로세스를 메모리에 올림**

| 용어         | 설명            |
| ------------ | --------------- |
| **Swap Out** | 메모리 → 디스크 |
| **Swap In**  | 디스크 → 메모리 |

> CPU 시간을 낭비하지 않고 여러 프로세스를 번갈아가면서 실행 가능

## 요약

- **가상 메모리**는 실제 메모리보다 큰 메모리를 쓰는 것처럼 보이게 하는 **운영체제 기술**
- **논리 주소 → 물리 주소** 변환을 **주소 바인딩**이라 하며,
- 이 과정을 **MMU**가 담당함
- 운영체제는 메모리를 효율적으로 사용하기 위해 **다이나믹 로딩, 다이나믹 링킹, 스와핑** 등의 방법을 사용함
