---
title: '프로세스 메모리 구조'
date: '2025-07-18 00:40'
description: '우리가 매일 사용하는 컴퓨터와 스마트폰에서 수많은 프로그램이 동시에 실행되고 있다. 프로그램, 즉 프로세스들은 대체 어떻게 메모리를 사용하여 동작하는 걸까? 뇌가 정보를 저장하고 처리하는 방식처럼, 프로세스 또한 자신만의 규칙적인 메모리 공간을 가지고 효율적으로 작동하고 있다.'
section: 'Computer Science'
category: '운영체제'
slug: '프로세스-메모리-구조'
tags: ['프로세스', 'OS', 'Computer Science', '메모리구조']
image: '/images/posts/post11/image.png'
---

# 시작하기

우리가 매일 사용하는 컴퓨터와 스마트폰에서 수많은 프로그램이 동시에 실행되고 있다. 프로그램, 즉 **프로세스**들은 대체 어떻게 메모리를 사용하여 동작하는 걸까? 뇌가 정보를 저장하고 처리하는 방식처럼, 프로세스 또한 자신만의 규칙적인 메모리 공간을 가지고 효율적으로 작동하고 있다.

하나의 프로세스가 운영체제로부터 할당받아 사용하는 메모리 공간은 단순히 한 덩어리가 아니라, 목적과 특성에 따라 여러 개의 구역으로 나뉘는데, 이러한 구역을 **메모리 세그먼트(Segment)** 라고 부르고 대표적으로 다음과 같은 영역들로 나뉘어진다.

## 프로세스 메모리 구조 (Text / Data / BSS / Heap / Stack)

### TEXT 섹션 (코드)

- 프로그램의 실행 코드(명령어)가 저장되는 영역이다
- 프로그램에 있는 함수 코드, 제어문, 상수 등을 포함한다
- 일반적으로 한 번 로딩하면 바뀌지 않는다
- 읽기 전용(Read-only)로 설정된다
- 여러 프로세스가 같은 프로그램을 실행하면 이 영역이 공유될 수 있다
- **참고**
  - JVM에서는 TEXT영역을 사용하지 않고, 메서드 영역 사용한다
  - node나 브라우저에서는 TEXT 영역 대신 코드 영역이 별도로 존재

### Data 영역

- 초기값이 있는 전역변수나 정적(static) 변수 저장공간
- 프로그램이 시작될때 이미 초기화된 값을 메모리에 올린다
- 예) `int count = 10;`

### BSS 영역 (Block Started by Symbol)

- 초기값이 없는 전역 변수나 정적변수
- 런타임시 0으로 자동 초기화됨
- 실행 파일 크기를 줄이기 위해 실제로는 값을 포함하지 않고, 운영체제가 실행 시 공간만 확보
- 예) `js
static int total; // 0으로 초기화됨
int buffer[1000]; // 명시적으로 값 없으면 BSS
    `

### Heap 영역

- 동적 메모리 할당시 사용하는 영역 (malloc, new 등)
- 크기가 가변적이고, 런타임 중 개발자에 의해 할당/해제 됨
- 힙 영역에 할당한 메모리 공간에 대한 주소를 참조하는 경우가 많다
- 위쪽(높은 주소)로 확장됨
- 메모리 누수(leak)의 원인 중 하나가 되는 곳
- 예)
  ```js
  let person = {
    name: 'mj',
    job: developer,
  };
  ```

### Stack 영역

- 함수를 호출할 때마다 지역변수, 매개 변수와 리턴값 등이 쌓인다
- 함수가 호출될 때마다 스택 프레임이 쌓이고 끝나면 사라짐(LIFO 구조)
- 아래쪽(낮은 주소)으로 확장됨
- 스택 크기를 초과하면 스택 오버플로우 발생

```js
  void foo() {
      int local = 0; // Stack 영역
  }
```

#### Stack Overflow가 생길 수 있는 경우

> 스택의 크기가 초과되면 발생한다!

- 재귀 호출이 너무 깊을때
- 지역 변수 크기가 너무 클때
- 함수 호출이 너무 많을때

#### V8 엔진 메모리 구조 Resident Set

- V8 엔진이란 ? Node.js에서 사용되는 자바스크립트 엔진이고, 이 엔진이 사용하는 메모리 구조를 분석할때 Resident Set의 개념이 사용된다
- Resident Set(RSS) : 프로세스가 실제로 RAM에 올려서 사용중인 물리적인 메모리 크기
- Resident Set을 구성하는 것들
  - 코드 영역 (Text Segment)
  - Stack
  - Heap (GC로 할당된 JS 객체들 포함)
  - 공유 라이브러리에서 이 프로세스가 현재 메모리에 유지하는 부분
  - 기타 OS가 관리하는 내부 구조

## 힙(Heap) vs 스택(Stack) 의 차이

| 항목                | **스택 (Stack)**                  | **힙 (Heap)**                               |
| ------------------- | --------------------------------- | ------------------------------------------- |
| 📌 메모리 할당 방식 | 컴파일러가 **자동으로 할당/해제** | 개발자가 **직접 할당/해제**                 |
| 📦 저장 대상        | 함수 호출 정보, 지역 변수         | 동적으로 생성된 객체, 배열 등               |
| 🔄 구조             | LIFO (Last-In, First-Out)         | 자유롭게 할당 및 해제                       |
| 🧠 메모리 위치      | 낮은 주소부터 위로 쌓임           | 높은 주소부터 아래로 확장                   |
| ⏱️ 속도             | 빠름 (고정적, 구조적)             | 느림 (단편화, GC 필요)                      |
| 🛠️ 관리             | 시스템/OS가 관리                  | 개발자 or GC(V8 등)이 관리                  |
| ⚠️ 문제 사례        | **Stack Overflow** (재귀 깊을 때) | **Memory Leak** (할당 후 해제 안함)         |
| 예시 코드 (C 기준)  | `int x = 10;` → 스택에 저장       | `int* p = malloc(sizeof(int));` → 힙에 저장 |

# 요약하기

- 프로세스는 효율적인 자원 관리를 위해서 Text, Data, BSS, Heap, Stack의 다섯 가지 주요 영역으로 나누어져있다
- Heap과 Stack은 할당 방식(자동 vs 수동/GC), 저장 대상, 구조, 메모리 성장 방향, 속도, 관리 주체, 발생 가능한 문제점에서 큰 차이가 있다
